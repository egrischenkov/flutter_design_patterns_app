{
  "main_title": "Паттерны Проектирования с Flutter",
  "theme": "Тема",
  "favorite": "Избранное",
  "nested_route": "Вложенная навигация",
  "pattern_types": "{patternTypeId, select, creational {Порождающие} structural {Структурные} behavioral {Поведенческие}}",
  "@pattern_types": {
    "placeholders": {
      "patternTypeId": {}
    }
  },
  "pattern_types_description": "{patternTypeId, select, creational {Отвечают за создание новых объектов} structural {Отвечают за построение удобных иерархий классов} behavioral {Решают задачи взаимодействия между объектами программы}}",
  "@pattern_types_description": {
    "placeholders": {
      "patternTypeId": {}
    }
  },
  "patterns_name": "{patternId, select, abstract_factory {Абстрактная фабрика} builder {Строитель} factory_method {Фабричный метод} prototype {Прототип} singleton {Одиночка} adapter {Адаптер} bridge {Мост} composite {Компоновщик} decorator {Декоратор} facade {Фасад} flyweight {Легковес} proxy {Заместитель} chain_of_responsibility {Цепочка обязанностей} command {Команда} iterator {Итератор} mediator {Посредник} memento {Снимок} observer {Наблюдатель} state {Состояние} strategy {Стратегия} template_method {Шаблонный метод} visitor {Посетитель}}",
  "@patterns_name": {
    "placeholders": {
      "patternId": {}
    }
  },
  "patterns_description": "{patternId, select, abstract_factory {Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов} builder {Позволяет создавать сложные объекты пошагово. Строитель дает возможность использовать один и тот же код строительства для получения разных представлений объектов}, factory_method {Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов} prototype {Позволяет копировать объекты, не вдаваясь в подробности их реализации} singleton {Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа} adapter {Позволяет объектам в несовместимыми интерфейсами работать вместе} bridge {Разделяет один или несколько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменять их независимо друг от друга} composite {Позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней как будто это единичный объект} decorator {Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные “обертки”} facade {Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку} flyweight {Позволяет вместить большое количество объектов в отведенную оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте} proxy {Позволяет подставлять вместо реальных объектов специальные объекты-заменители} chain_of_responsibility {Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи} command {Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, легировать их, а также поддерживать подмену операций} iterator {Дает возможность последовательно обходить элементы составных объектов, не раскрывая внутреннего представления} mediator {Позволяет уменьшить связность множества классов между собой, благодаря перемещению этих связей в один класс-посредник} memento {Позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации} observer {Создает механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах} state {позволяет объектам менять свое поведение в зависимости от своего состояния. Извне создается впечатление, что изменился класс объекта} strategy {определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменяем прямо во время исполнения программы} template_method {Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры} visitor {Позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться}}",
  "@patterns_description": {
    "placeholders": {
      "patternId": {}
    }
  },
  "patterns": "{COUNT} паттернов",
  "@patterns": {
    "placeholders": {
      "COUNT": {}
    }
  },
  "example": "Пример",
  "description": "Описание",
  "warning_no_favorite": "Ой, избранных паттернов пока что нет!",
  "language": "Язык",
  "add_to_favorite": "Паттерн {PATTERN} добавлен в избранное",
  "@add_to_favorite": {
    "placeholders": {
      "PATTERN": {}
    }
  },
  "remove_from_favorite": "Паттерн {PATTERN} удален из избранного",
  "@remove_from_favorite": {
    "placeholders": {
      "PATTERN": {}
    }
  }
}